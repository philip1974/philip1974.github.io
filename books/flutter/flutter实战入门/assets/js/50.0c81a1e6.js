(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{751:function(e,n,s){"use strict";s.r(n);var a=s(44),t=Object(a.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("https://medium.com/flutter/flutter-platform-channels-ce7f540a104e")]),e._v(" "),s("h1",{attrs:{id:"flutter-platform-channels"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flutter-platform-channels"}},[e._v("#")]),e._v(" Flutter Platform Channels")]),e._v(" "),s("p",[e._v("“漂亮的用户界面。但是Flutter如何处理平台特定的API？”")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://flutter.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flutter"),s("OutboundLink")],1),e._v("邀请您使用Dart编程语言编写您的移动应用，并为Android和iOS进行构建。但是Dart不能编译为Android的Dalvik字节码，也无法在iOS上使用Dart / Objective-C绑定。这意味着您编写的Dart代码无需直接访问iOS Cocoa Touch和Android SDK的特定于平台的API。")]),e._v(" "),s("p",[e._v("只要您只写Dart在屏幕上绘制像素，这并不是什么大问题。Flutter框架及其底层图形引擎非常有能力自行实现。如果您除了画像素以外所做的一切都是文件或网络I / O以及相关的业务逻辑，这也不是问题。Dart语言，运行时和库已在此处介绍。")]),e._v(" "),s("p",[e._v("但非平凡的应用程序需要与主机平台进行更深层次的集成：")]),e._v(" "),s("ul",[s("li",[e._v("通知，应用生命周期，深层链接……")]),e._v(" "),s("li",[e._v("传感器，相机，电池，地理位置，声音，连接性……")]),e._v(" "),s("li",[e._v("与其他应用共享信息，启动其他应用，…")]),e._v(" "),s("li",[e._v("持久的首选项，特殊文件夹，设备信息，...")])]),e._v(" "),s("p",[e._v("该列表范围很广，并且似乎随着每个平台版本的增长而增长。")]),e._v(" "),s("p",[e._v("对所有这些平台API的访问都可以嵌入Flutter框架本身。但这将使Flutter变得更大，并为它提供更多改变的理由。实际上，这可能会导致Flutter落后于最新的平台版本。或使用平台API的“最小公分母”包装不能令人满意的登陆应用程序作者。或以笨拙的抽象使困惑的新手困惑于平台差异。或版本碎片。或错误。")]),e._v(" "),s("p",[e._v("想一想，可能是以上所有情况。")]),e._v(" "),s("p",[e._v("Flutter团队选择了另一种方法。它并不能做很多事情，但是它简单，通用并且完全在您手中。")]),e._v(" "),s("p",[e._v("首先，"),s("strong",[e._v("Flutter")]),e._v("由环境Android或iOS应用"),s("strong",[e._v("托管")]),e._v("。该应用程序的Flutter部分包装在特定于标准平台的组件中，例如"),s("code",[e._v("View")]),e._v("在Android和"),s("code",[e._v("UIViewController")]),e._v("iOS上。因此，尽管Flutter邀请您使用Dart编写应用程序，但是您可以在主机应用程序中直接在特定于平台的API之上使用Java / Kotlin或Objective-C / Swift进行任意操作。")]),e._v(" "),s("p",[e._v("第二， "),s("a",{attrs:{href:"https://flutter.io/platform-channels/",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[e._v("平台渠道")]),s("OutboundLink")],1),e._v(" 提供一种用于在Dart代码与主机应用程序的特定于平台的代码之间进行通信的简单机制。这意味着您可以在主机应用程序代码中公开平台服务，并从Dart端调用它。或相反亦然。")]),e._v(" "),s("p",[e._v("第三，"),s("a",{attrs:{href:"https://flutter.io/developing-packages/",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[e._v("插件")]),s("OutboundLink")],1),e._v("使创建以Java或Kotlin编写的Android实现和以Objective-C或Swift编写的iOS实现为后盾的Dart API成为可能，并将它们打包为Flutter / Android / iOS，使用平台将其粘合在一起渠道。这意味着您可以使用，分享和分发"),s("em",[e._v("您拿")]),e._v("上扑应该如何使用特定平台的API。")]),e._v(" "),s("p",[e._v("本文是对平台渠道的深入介绍。从Flutter的消息传递基础开始，我将介绍消息/方法/事件通道的概念，并讨论一些API设计注意事项。没有API清单，而是用于复制粘贴重用的简短代码示例。根据我作为Flutter团队成员对"),s("a",{attrs:{href:"https://github.com/flutter/plugins",target:"_blank",rel:"noopener noreferrer"}},[e._v("flutter / plugins"),s("OutboundLink")],1),e._v(" GitHub存储库所做的贡献，提供了使用指南的简要列表。本文以其他资源列表结尾，包括指向DartDoc / JavaDoc / ObjcDoc参考API的链接。")]),e._v(" "),s("h2",{attrs:{id:"目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[e._v("#")]),e._v(" 目录")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[e._v("平台通道API")]),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("基础：异步，二进制消息传递"),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("消息通道：名称+编解码器"),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("方法通道：标准化信封"),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("事件通道：流"),s("OutboundLink")],1),e._v("**\n**")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[e._v("使用指南")]),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("按域在通道名称前添加前缀以确保唯一性"),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("考虑将平台通道视为模块内通信"),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("不要模拟平台通道"),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("考虑对平台交互进行自动测试"),s("OutboundLink")],1),s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[e._v("保持平台端准备好传入的同步呼叫"),s("OutboundLink")],1),e._v("**\n**")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://medium.com/p/ce7f540a104e",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[e._v("资源资源")]),s("OutboundLink")],1)]),e._v(" "),s("h1",{attrs:{id:"平台渠道api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#平台渠道api"}},[e._v("#")]),e._v(" 平台渠道API")]),e._v(" "),s("p",[e._v("对于大多数用例，您可能会使用"),s("em",[e._v("方法通道")]),e._v("进行平台通信。但是，由于它们的许多属性都来自更简单的"),s("em",[e._v("消息通道")]),e._v("以及基础的"),s("em",[e._v("二进制消息传递")]),e._v("基础，因此我将从此处开始。")]),e._v(" "),s("h2",{attrs:{id:"基础：异步，二进制消息传递"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础：异步，二进制消息传递"}},[e._v("#")]),e._v(" 基础：异步，二进制消息传递")]),e._v(" "),s("p",[s("img",{attrs:{src:"http://img.laomengit.com/20210510214533.png",alt:""}})]),e._v(" "),s("p",[e._v("在最基本的级别上，Flutter使用带有二进制消息的异步消息传递来与平台代码进行对话-意味着消息有效负载是字节缓冲区。为了区分用于不同目的的消息，每条消息都是在逻辑“通道”上发送的，该通道仅是名称字符串。下面的示例使用通道名称"),s("code",[e._v("foo")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//从Dart向平台发送二进制消息。最后的 WriteBuffer缓冲区= WriteBuffer（）\n  ..putFloat64（3.1415）\n  ..putInt32（12345678）; \n最终的 ByteData消息= buffer.done（）; \n等待 BinaryMessages.send（'foo'，message）; \nprint（'消息已发送，忽略回复'）;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("在Android上，可以"),s("code",[e._v("java.nio.ByteBuffer")]),e._v("使用以下Kotlin代码以形式接收此类消息：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//从Android上的Dart接收二进制消息。\n//可以将此代码添加到FlutterActivity子类中，通常\n在onCreate中。flutterView.setMessageHandler（“ foo”）{  消息，回复->\n   message.order（ByteOrder.nativeOrder（））\n  val x = message.double val n = message.int   Log.i（“ MSG”，“接收：$ x和$ n“）  reply.reply（null）}\n  \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("该"),s("code",[e._v("ByteBuffer")]),e._v("API支持在自动前进当前读取位置的同时读取原始值。iOS上的故事与此类似。非常欢迎提出改善我的弱Swift的建议：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//在iOS上从Dart接收二进制消息。\n//此代码可以添加到FlutterAppDelegate子类中，\n//通常在application：didFinishLaunchingWithOptions：中。让 flutterView = \n  window？.rootViewController 为！FlutterViewController; \nflutterView.setMessageHandlerOnChannel（“ foo”）{ \n  （消息：数据！，回复：FlutterBinaryReply）-> 在\n  let x中无效：Float64 = message.subdata（in：0 .. <8）\n    .withUnsafeBytes {$ 0.pointee} \n  let n： Int32 = message.subdata（in：8 .. <12）\n    .withUnsafeBytes {$ 0.pointee} \n  os_log（“已接收％f和％d”，x，n）\n  回复（nil）\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("通信是双向的，因此您也可以从Java / Kotlin或Objective-C / Swift向Dart发送相反的消息。反转上述设置的方向如下所示：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//从Android发送二进制消息。val message = ByteBuffer.allocateDirect（12）\nmessage.putDouble（3.1415）\nmessage.putInt（123456789）\nflutterView.send（“ foo”，message）{ \n  _- > Log.i（“ MSG”，“已发送消息，忽略了答复” ）\n}\n//从iOS发送二进制消息。var message =数据（容量：12）\nvar x：Float64 = 3.1415 \nvar n：Int32 = 12345678 \nmessage.append（UnsafeBufferPointer（开始：＆x，计数：1））\nmessage.append（UnsafeBufferPointer（开始：＆n，计数：1） ）\nflutterView.send（同频： “foo”的，消息：消息）{（_） - >空隙中\n   os_log（ “消息发送，回复忽略”）\n}\n//从平台接收二进制消息。BinaryMessages.setMessageHandler（ '富'，（ByteData消息）异步 { \n  最终 ReadBuffer readBuffer = ReadBuffer（消息）; \n  最终双X = readBuffer.getFloat64（）; \n  最终 INT N = readBuffer.getInt32（）; \n  印刷（“收到$ x和$ n'）; \n  返回 null; \n}）;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br")])]),s("p",[e._v("**精美的印刷品。***强制性答复。*每个消息发送都涉及接收方的异步答复。在上面的示例中，没有有趣的值可以进行回传，但是null回复对于Dart的将来完成和两个平台回调的执行是必需的。")]),e._v(" "),s("p",[e._v("*线程。*在平台的主UI线程上接收并必须发送消息和答复。在Dart中，每个Dart隔离区（即，每个Flutter视图）只有一个线程，因此对于在此处使用哪个线程没有混淆。")]),e._v(" "),s("p",[e._v("*例外情况。*在Dart或Android消息处理程序中引发的任何未捕获的异常都将被框架捕获并记录下来，并且将空响应发送回发送方。记录在回复处理程序中引发的未捕获异常。")]),e._v(" "),s("p",[e._v("*处理程序生命周期。*已注册的消息处理程序将与Flutter视图（意味着Dart隔离，Android "),s("code",[e._v("FlutterView")]),e._v("实例和iOS "),s("code",[e._v("FlutterViewController")]),e._v("）一起保留并保持活动状态。您可以通过注销处理程序来缩短处理程序的寿命：只需使用相同的通道名设置一个null（或不同）的处理程序即可。")]),e._v(" "),s("p",[e._v("*处理程序的唯一性。*处理程序保存在以通道名称为键的哈希映射中，因此每个通道最多可以有一个处理程序。使用空答复自动响应在接收端未注册任何消息处理程序的通道上发送的消息。")]),e._v(" "),s("p",[e._v("*同步通讯。*平台通信仅在异步模式下可用。这样可以避免在线程之间进行阻塞调用以及可能引起的系统级问题（性能低下，出现死锁的风险）。在撰写本文时，尚不清楚在Flutter中是否确实需要同步通信，如果需要，则以什么形式。")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("在二进制消息级别工作，您需要担心字节序之类的微妙细节，以及如何使用字节表示更高级别的消息（例如字符串或映射）。每当您要发送消息或注册处理程序时，还需要指定正确的通道名称。使它变得更容易使我们进入平台渠道：")]),e._v(" "),s("p",[s("em",[e._v("平台通道是一个对象，它将通道名称和编解码器组合在一起，用于将消息序列化/反序列化为二进制形式并返回")]),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"消息通道：名称-编解码器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息通道：名称-编解码器"}},[e._v("#")]),e._v(" 消息通道：名称+编解码器")]),e._v(" "),s("p",[s("img",{attrs:{src:"http://img.laomengit.com/20210510214551.png",alt:"img"}})]),e._v(" "),s("p",[e._v("假设您要发送和接收字符串消息，而不是字节缓冲区。可以使用消息通道（一种简单的平台通道，由字符串编解码器构造）完成此操作。以下代码显示了如何在Dart，Android和iOS的两个方向上使用消息通道：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//字符串消息//飞镖面const channel = BasicMessageChannel <String>（'foo'，StringCodec（））;//向平台发送消息并接收回复。\n最后的 String答复= 等待 channel.send（'Hello，world'）; \n打印（回复）;//从平台接收消息并发送回复。\nchannel.setMessageHandler（（字符串消息）异步 { \n  打印（ '收稿日期：$消息'）; \n  返回 '嗨从DART'; \n}）;\n// Android端val channel = BasicMessageChannel <String>（\n  flutterView，“ foo”，StringCodec.INSTANCE）//向Dart发送消息并接收回复。\nchannel.send（“ Hello，world”）{回复-> \n  Log.i（“ MSG”，回复）\n}//接收来自Dart的消息并发送回复。\nchannel.setMessageHandler {消息，回复-> \n  Log.i（“ MSG”，“已接收：$ message”）\n  reply.reply（“来自Android的嗨”）\n}\n// iOS端let channel = FlutterBasicMessageChannel（\n    name：“ foo”，\n    binaryMessenger：controller，\n    codec：FlutterStringCodec.sharedInstance（））//向Dart发送消息并接收回复。\nchannel.sendMessage（“ Hello，world”）{（回复：任何？）->   os_log（“％@” 中的\n空白，请输入：.info，回复为！String）\n}//接收来自Dart的消息并发送回复。\nchannel.setMessageHandler { \n  （（消息：任意？，答复：FlutterReply）->   os_log 中的\n无效（“ Received：％@”，键入：.info，消息为！String）\n  Reply（“ Hi from iOS”）\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br")])]),s("p",[e._v("通道名称仅在通道构造时指定。此后，无需重复通道名称即可完成发送消息或设置消息处理程序的调用。更重要的是，我们将其留给字符串编解码器类来处理如何将字节缓冲区解释为字符串，反之亦然。")]),e._v(" "),s("p",[e._v("可以肯定地说，这些都是高贵的优势，但是您可能会同意，"),s("code",[e._v("BasicMessageChannel")]),e._v("并不能做那么多。这是故意的。上面的Dart代码等效于二进制消息传递基础的以下用法：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const codec = StringCodec（）;//向平台发送消息并接收回复。\n最后的 String Reply = codec.decodeMessage（\n  等待 BinaryMessages.send（\n    'foo'，\n    codec.encodeMessage（'Hello，world'），\n  ），\n）; \n打印（回复）;//从平台接收消息并发送回复。\nBinaryMessages.setMessageHandler（'foo'，（ByteData message）async { \n  print（'Received：$ {codec.decodeMessage（message）}'）; \n  返回 codec.encodeMessage（'来自Dart的嗨'）; \n}）;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br")])]),s("p",[e._v("此备注也适用于消息通道的"),s("a",{attrs:{href:"https://docs.flutter.io/javadoc/io/flutter/plugin/common/BasicMessageChannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android"),s("OutboundLink")],1),e._v("和"),s("a",{attrs:{href:"https://docs.flutter.io/objcdoc/Classes/FlutterBasicMessageChannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS"),s("OutboundLink")],1),e._v("实现。"),s("em",[e._v("没有魔术")]),e._v("：")]),e._v(" "),s("ul",[s("li",[e._v("消息通道委托给二进制消息传递层进行所有通信。")]),e._v(" "),s("li",[e._v("消息通道不跟踪注册的处理程序本身。")]),e._v(" "),s("li",[e._v("消息通道轻巧且无状态。")]),e._v(" "),s("li",[e._v("使用相同的通道名称和编解码器创建的两个消息通道实例是等效的（并且会干扰彼此的通信）。")])]),e._v(" "),s("p",[e._v("由于各种历史原因，Flutter框架定义了四种不同的消息编解码器：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("StringCodec")]),e._v("使用UTF-8编码字符串。如我们所见，带有此编解码器的消息通道已输入"),s("code",[e._v("BasicMessageChannel")]),e._v("Dart。")]),e._v(" "),s("li",[s("code",[e._v("BinaryCodec")]),e._v("通过在字节缓冲区上实现身份映射，此编解码器使您在不需要编码/解码的情况下享受通道对象的便利。具有此编解码器的Dart消息通道的类型为"),s("code",[e._v("BasicMessageChannel")]),e._v("。")]),e._v(" "),s("li",[s("code",[e._v("JSONMessageCodec")]),e._v("处理“类似于JSON”的值（字符串，数字，布尔值，null，此类值的列表以及此类值的字符串键映射）。列表和地图是异构的，可以嵌套。在编码期间，这些值将转换为JSON字符串，然后使用UTF-8转换为字节。Dart消息通道具有"),s("code",[e._v("BasicMessageChannel")]),e._v("此编解码器的类型。")]),e._v(" "),s("li",[s("code",[e._v("StandardMessageCodec")]),e._v("优惠比JSON编解码器稍微更广义的值，也支持同质数据缓冲器（"),s("code",[e._v("UInt8List")]),e._v("，"),s("code",[e._v("Int32List")]),e._v("，"),s("code",[e._v("Int64List")]),e._v("，"),s("code",[e._v("Float64List")]),e._v("）和地图与非字符串键。数字的处理与JSON不同，Dart int在平台上以32或64位带符号整数形式到达，具体取决于幅度-决不作为浮点数。将值编码为自定义，合理紧凑和可扩展的二进制格式。标准编解码器被设计为Flutter中通道通信的默认选择。对于JSON，使用标准编解码器构造的Dart消息通道的类型为"),s("code",[e._v("BasicMessageChannel")]),e._v("。")])]),e._v(" "),s("p",[e._v("您可能已经猜到了，消息通道可与任何满足简单协定的消息编解码器实现一起使用。这使您可以根据需要插入自己的编解码器。您必须在Dart，Java / Kotlin和Objective-C / Swift中实现兼容的编码和解码。")]),e._v(" "),s("p",[s("strong",[e._v("精美的印刷品。")]),e._v(" "),s("em",[e._v("编解码器的演变")]),e._v("。每个消息编解码器都可以在Dart中使用，既可以作为Flutter框架的一部分，也可以在两种平台上使用，也可以作为Flutter向Java / Kotlin或Objective-C / Swift代码公开的库的一部分。Flutter仅将编解码器用于应用程序内通信，而不会将其用作持久性格式。这意味着消息的二进制形式可能会从Flutter的一个版本更改为下一个版本，而不会发出警告。当然，Dart，Android和iOS编解码器实现是一起发展的，以确保由发送者编码的内容可以在两个方向上被接收者成功解码。")]),e._v(" "),s("p",[e._v("*空消息。*任何消息编解码器都必须支持和保留空消息，因为这是对在接收方未注册任何消息处理程序的通道上发送的消息的默认答复。")]),e._v(" "),s("p",[e._v("*在Dart中静态键入消息。*配置有标准消息编解码器的消息通道"),s("code",[e._v("dynamic")]),e._v("为消息和回复提供类型。通常，您可以通过分配给类型变量来明确类型期望：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("最后的 String Reply1 = 等待 channel.send（msg1）; \n最后的 int Reply2 = 等待 channel.send（msg2）;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("但是在处理涉及泛型类型参数的答复时有一个警告：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("最终 List <String> Reply3 = 等待 channel.send（msg3）;      //失败。\n最终 List <dynamic> Reply3 = 等待 channel.send（msg3）;     //有效。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("第一行在运行时失败，除非答复为null。标准消息编解码器是为异构列表和映射编写的。在Dart方面，它们具有运行时类型"),s("code",[e._v("List")]),e._v("和"),s("code",[e._v("Map")]),e._v("，并且Dart 2可以防止将此类值分配给具有更特定类型参数的变量。这种情况类似于Dart JSON反序列化，后者会生成JSON编码解码器，"),s("code",[e._v("List")]),e._v("并且也会生成"),s("code",[e._v("Map")]),e._v("JSON消息编解码器。")]),e._v(" "),s("p",[e._v("期货会让您陷入类似的麻烦：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Future <String> greet（）=> channel.send（'hello，world'）;    //失败。\nFuture <String> greet（）async {                              //起作用。\n  最后的 String答复= 等待 channel.send（'hello，world'）; \n  返回回复；\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("即使收到的答复是字符串，第一个方法在运行时也会失败。通道实现会创建一个"),s("code",[e._v("Future")]),e._v("无论答复类型如何的对象，并且此类对象无法分配给"),s("code",[e._v("Future")]),e._v("。")]),e._v(" "),s("p",[s("em",[e._v("为什么在BasicMessageChannel中使用“基本”？"),s("em",[e._v("消息通道似乎仅在相当有限的情况下使用，在这种情况下您正在隐式上下文中交流某种形式的同类事件流。就像键盘事件一样。对于大多数平台渠道的应用程序，您不仅需要传达值，还需要传达您希望每个值发生什么，或者您希望接收者如何解释它。一种方法是让消息代表以值作为参数的方法调用。因此，您需要一种将消息中的方法名称与参数分开的标准方法。而且，您还需要一种区分成功和错误回复的标准方法。这就是渠道为您服务的")]),e._v("方法")]),e._v("。现在，"),s("code",[e._v("BasicMessageChannel")]),e._v("原名"),s("code",[e._v("MessageChannel")]),e._v("，但已重命名以避免"),s("code",[e._v("MessageChannel")]),e._v("与"),s("code",[e._v("MethodChannel")]),e._v("代码混淆。方法通道更为通用，因此名称更短。")]),e._v(" "),s("h2",{attrs:{id:"方法渠道：标准化信封"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法渠道：标准化信封"}},[e._v("#")]),e._v(" 方法渠道：标准化信封")]),e._v(" "),s("p",[s("img",{attrs:{src:"http://img.laomengit.com/20210510214604.png",alt:""}})]),e._v(" "),s("p",[e._v("方法通道是平台通道，旨在在Dart和Java / Kotlin或Objective-C / Swift中调用命名的代码段。方法通道使用标准化的消息“信封”将方法名称和参数从发送者传递到接收者，并在关联的回复中区分成功结果和错误结果。信封和受支持的有效负载是由单独的方法编解码器类定义的，类似于消息通道如何使用消息编解码器。")]),e._v(" "),s("p",[s("em",[e._v("这就是方法通道所做的全部工作：将通道名称与编解码器组合在一起。")])]),e._v(" "),s("p",[e._v("特别是，没有假设在方法通道上收到消息后执行什么代码。即使消息代表方法调用，您也不必调用方法。您可能只是打开方法名称并为每种情况执行几行代码。")]),e._v(" "),s("p",[e._v("**边注。**缺少对方法及其参数的隐式或自动绑定可能会使您感到失望。很好，失望可以产生成果。我想您可以使用注释处理和代码生成从头开始构建这样的解决方案，或者您可以重用现有RPC框架的某些部分。Flutter是开源的，"),s("a",{attrs:{href:"https://github.com/flutter/flutter/blob/master/CONTRIBUTING.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("随时可以贡献"),s("OutboundLink")],1),e._v("！如果方法通道符合要求，则可以将其用作代码生成的目标。同时，它们在“手工模式”下非常有用。")]),e._v(" "),s("p",[e._v("方法渠道是Flutter团队应对的挑战，即定义一个可行的通信API以供当时不存在的插件生态系统使用。我们想要插件作者可以立即使用的东西，而无需大量样板文件或复杂的构建设置。我认为方法渠道的概念是一个不错的答案，但是如果它仍然是"),s("em",[e._v("唯一的")]),e._v("答案，我会感到惊讶。")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("在从Dart调用一些平台代码的简单情况下，这就是使用方法通道的方式。该代码与该名称相关联，"),s("code",[e._v("bar")]),e._v("在这种情况下，该名称不是方法名称，但可以这样。它所做的只是构造一个问候字符串并将其返回给调用者，因此我们可以在合理的前提下（平台调用不会失败）进行编码（我们将在下面进一步处理错误处理）：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//调用平台方法，简单的情况。//飞镖面。const channel = MethodChannel（'foo'）; \n最后的字符串问候语=等待 channel.invokeMethod（'bar'，'world'）; \n打印（问候）；\n// Android端。VAL信道= MethodChannel（flutterView， “foo”的）\nchannel.setMethodCallHandler {呼叫，结果- > \n  时（call.method）{ \n    “栏中的” - > result.success（ “你好，$ {call.arguments}”）\n    其他 - > result.notImplemented（）\n  } \n}// iOS端。让信道= FlutterMethodChannel（\n  名称： “foo”的，binaryMessenger：flutterView）\nchannel.setMethodCallHandler { \n  （呼叫：FlutterMethodCall，结果：FlutterResult） - >空隙在\n  开关（call.method）{ \n  情况 “条”：结果（“你好，\\ （call.arguments as！String）“）\n  默认值：result（FlutterMethodNotImplemented）\n  } \n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[e._v("通过在switch构造中添加案例，我们可以轻松地将上述内容扩展为处理多种方法。default子句处理调用未知方法的情况（很可能是由于编程错误）。")]),e._v(" "),s("p",[e._v("上面的Dart代码等效于以下代码：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const编解码器= StandardMethodCodec（）;最终的 ByteData答复= 等待 BinaryMessages。发送（\n  'foo'，\n  codec.encodeMethodCall（MethodCall（'bar'，'world'）），\n）; \n如果（reply == null）\n  抛出 MissingPluginException（）; \n否则\n   print（codec.decodeEnvelope（reply））;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("方法通道的"),s("a",{attrs:{href:"https://docs.flutter.io/javadoc/io/flutter/plugin/common/MethodChannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android"),s("OutboundLink")],1),e._v("和"),s("a",{attrs:{href:"https://docs.flutter.io/objcdoc/Classes/FlutterMethodChannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS"),s("OutboundLink")],1),e._v("实现类似地是对二进制消息传递基础的调用的瘦包装器。空答复用于表示“未实现”结果。这很方便地使接收端的行为与调用是否落入开关中的default子句无关，或者根本没有在通道中注册任何方法调用处理程序。")]),e._v(" "),s("p",[e._v("示例中的参数值是单个字符串"),s("code",[e._v("world")]),e._v("。但是默认方法编解码器，恰当地命名为“标准方法编解码器”，在后台使用标准"),s("em",[e._v("消息")]),e._v("编解码器来编码有效载荷值。这意味着，前面介绍的“类似于JSON的通用”值都支持作为方法参数和（成功的）结果。特别是，异构列表支持多个参数，而异构映射则支持命名参数。默认参数值为null。一些例子：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("等待 channel.invokeMethod（'bar'）; \n等待 channel.invokeMethod（'bar'，<dynamic> ['world'，42，pi]）; \n等待 channel.invokeMethod（'bar'，<String，dynamic> { \n  名称：'world'，\n  答案：42，\n  数学：pi，\n}）））;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("Flutter SDK包含两个方法编解码器：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("StandardMethodCodec")]),e._v("默认情况下，它将有效载荷值的编码委托给"),s("code",[e._v("StandardMessageCodec")]),e._v("。因为后者是可扩展的，所以前者也是可扩展的。")]),e._v(" "),s("li",[s("code",[e._v("JSONMethodCodec")]),e._v("将有效负载值的编码委托给"),s("code",[e._v("JSONMessageCodec")]),e._v("。")])]),e._v(" "),s("p",[e._v("您可以使用任何方法编解码器（包括自定义代码编解码器）来配置方法通道。为了完全理解实现编解码器所涉及的内容，让我们通过使用易犯错误的"),s("code",[e._v("baz")]),e._v("方法扩展上面的示例，看看如何在方法通道API级别处理错误：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//具有错误处理的方法调用。//飞镖面。const channel = MethodChannel（'foo'）;//调用平台方法。\nconst name ='bar'; //或'baz'，或' \nunknown'const value ='world'; \n尝试 { \n  打印（等待 channel.invokeMethod（名称，值））; \n} on PlatformException catch（e）{ \n  print（'$ name failed：$ {e.message}'）; \n} 关于 MissingPluginException { \n  print（'未实现$ name'）; \n}//从平台接收方法调用并返回结果。\nchannel.setMethodCallHandler（（MethodCall呼叫）异步 { \n  开关（call.method）{ \n    情况下 '酒吧'：\n      返回 '你好，$ {call.arguments}'; \n    壳体 '巴兹'：\n      掷 PlatformException（代码： '400'，消息： '这很糟糕'）; \n    默认值：\n      throw MissingPluginException（）; \n  } \n}）;\n// Android端。val channel = MethodChannel（flutterView，“ foo”）//调用Dart方法。\nval name =“ bar” //或“ baz”，或“ unknown” \nval value =“ world” \nchannel.invokeMethod（名称，值，对象：MethodChannel.Result { \n  重写fun success（结果：任何？）{ \n    Log.i （“ MSG”，“ $ result”）\n  } \n  重写fun错误（代码：String ?， msg：String ?，详细信息：任意？）{ \n    Log.e（“ MSG”，“ $ name failed：$ msg”）\n  } \n  覆盖fun notImplemented（）{ \n    Log.e（“ MSG”，“未实现$ name”）\n  } \n}）//从Dart接收方法调用并返回结果。\nchannel.setMethodCallHandler {呼叫，结果-> \n  when（call.method）{ \n    “ bar”-> result.success（“ Hello，$ {call.arguments}”）\n    “ baz”-> result.error（“ 400”，“这很糟糕”，null），\n    否则 -> result.notImplemented（）\n  } \n}\n// iOS端。let channel = FlutterMethodChannel（\n  name：“ foo”，binaryMessenger：flutterView）//调用Dart方法。\n让 NAME =“酒吧” //或“巴兹”或“未知” \n让价值=“世界” \nchannel.invokeMethod（名称，参数：值）{ \n  （结果：任意） - >虚空中\n  ，如果 让错误=结果为？FlutterError { \n    os_log（“％@失败：％@”，类型：.error，名称，错误。消息！）\n  } 否则，如果 FlutterMethodNotImplemented.isEqual（result）{ \n    os_log（“％@未实现”，类型： ）\n  } else { \n    os_log（“％@”，类型：.info，结果为！NSObject）\n  } \n}//从Dart接收方法调用并返回结果。\nchannel.setMethodCallHandler { \n  （电话：FlutterMethodCall，结果是：FlutterResult） - >虚空中的\n  开关（call.method）{ \n  案 “吧”：结果（ “你好，\\（call.arguments 作为！字符串）”）\n  情况下， “巴兹”： result（FlutterError（\n    代码：“ 400”，消息：“ This is bad”，详细信息：nil））\n  默认值：result（FlutterMethodNotImplemented）\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br"),s("span",{staticClass:"line-number"},[e._v("59")]),s("br"),s("span",{staticClass:"line-number"},[e._v("60")]),s("br"),s("span",{staticClass:"line-number"},[e._v("61")]),s("br"),s("span",{staticClass:"line-number"},[e._v("62")]),s("br"),s("span",{staticClass:"line-number"},[e._v("63")]),s("br")])]),s("p",[e._v("错误是三元组（代码，消息，详细信息），其中代码和消息是字符串。该消息供人类食用，代码也就是代码。错误详细信息是一些自定义值，通常为null，仅受编解码器支持的值种类的约束。")]),e._v(" "),s("p",[e._v("**精美的印刷品。***例外情况。*Dart或Android方法调用处理程序中引发的任何未捕获的异常都会被通道实现捕获并记录下来，并且错误结果会返回给调用者。记录在结果处理程序中引发的未捕获的异常。")]),e._v(" "),s("p",[s("em",[e._v("信封编码。"),s("em",[e._v("方法编解码器如何编码其信封是一个实现细节，就像消息编解码器如何将消息转换为字节一样。例如，方法编解码器可能使用列表：方法调用可以编码为两个元素的列表[方法名，参数]；成功结果作为一个要素列表[结果]；错误结果为三元素列表[代码，消息，详细信息]。然后，可以通过委派给至少支持列表，字符串和null 的基础")]),e._v("消息")]),e._v("编解码器来简单地实现这种方法编解码器。方法调用参数，成功结果和错误详细信息将是该消息编解码器支持的任意值。")]),e._v(" "),s("p",[e._v("*API差异。*上面的代码示例突出说明了方法通道在Dart，Android和iOS上交付结果的方式非常不同：")]),e._v(" "),s("ul",[s("li",[e._v("在Dart端，调用由返回远期的方法处理。在成功的情况下，"),s("code",[e._v("PlatformException")]),e._v("在错误的情况下以及"),s("code",[e._v("MissingPluginException")]),e._v("未实现的情况下，调用结果将以future结束。")]),e._v(" "),s("li",[e._v("在Android上，调用由带有回调参数的方法处理。回调接口定义了三种方法，取决于结果。客户端代码实现了回调接口，以定义成功，错误以及未实现时应该发生的情况。")]),e._v(" "),s("li",[e._v("在iOS上，调用类似地由采用回调参数的方法处理。但是在这里，回调是一个单参数函数，为该函数提供了"),s("code",[e._v("FlutterError")]),e._v("实例，"),s("code",[e._v("FlutterMethodNotImplemented")]),e._v("常量或调用结果（如果成功的话）。客户端代码根据需要为块提供了条件逻辑来处理不同的情况。")])]),e._v(" "),s("p",[e._v("这些差异也反映在编写消息调用处理程序的方式上，作为对Flutter SDK方法通道实现所使用的编程语言（Dart，Java和Objective-C）样式的让步。重做Kotlin和Swift中的实现可能会消除一些差异，但是必须注意避免增加使用Java和Objective-C中的方法通道的难度。")]),e._v(" "),s("h2",{attrs:{id:"活动频道：流媒体"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#活动频道：流媒体"}},[e._v("#")]),e._v(" 活动频道：流媒体")]),e._v(" "),s("p",[s("img",{attrs:{src:"http://img.laomengit.com/20210510214701.png",alt:"img"}})]),e._v(" "),s("p",[e._v("事件通道是专门的平台通道，旨在用于将平台事件作为Dart流公开给Flutter的用例。Flutter SDK当前不支持将Dart流公开给平台代码的对称情况，但是如果需要可以构建。")]),e._v(" "),s("p",[e._v("这是在Dart端使用平台事件流的方式：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//在Dart端消耗事件。const channel = EventChannel（'foo'）;channel.receiveBroadcastStream（）。listen（（动态事件）{ \n  print（'接收事件：$ event'）; \n}，onError ：（动态错误）{ \n  print（'接收错误：$ {error.message}'）; \n}） ;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("下面的代码以Android上的传感器事件为例，展示了如何在平台端生成事件。主要关注的问题是确保我们正在侦听来自平台源（在这种情况下为传感器管理器）的事件，并在以下情况下准确地通过事件通道发送事件：1）Dart端至少有一个流侦听器，以及2）环境"),s("code",[e._v("Activity")]),e._v("正在运行。将必要的逻辑打包到一个类中可以增加正确执行此操作的机会：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//在Android上生成传感器事件。// SensorEventListener / EventChannel适配器。\nclass SensorListener（private val sensorManager：SensorManager）：\n  EventChannel.StreamHandler，SensorEventListener { \n  private var eventSink：EventChannel.EventSink？= null \n\n  // EventChannel.StreamHandler方法\n  重写fun onListen（\n    参数：Any ?, eventSink：EventChannel.EventSink？）{ \n    this .eventSink = eventSink \n    registerIfActive（）\n  } \n  重写fun onCancel（arguments：Any？）{ \n    unregisterIfActive（）\n    eventSink = null \n  } \n\n  // SensorEventListener方法。\n  重写fun onSensorChanged（event：SensorEvent）{\n    ？EventSink的.success（event.values）\n  } \n  覆盖乐趣 onAccuracyChanged（传感器：传感器?,精度：智力）{ \n    如果（精度== SensorManager.SENSOR_STATUS_ACCURACY_LOW）\n      ？EventSink的.error（ “SENSOR”， “低精度检测”，NULL）\n  }  //生命周期方法。\n  有趣的 registerIfActive（）{ \n    如果（eventSink == null）返回\n     sensorManager.registerListener（\n      this，\n      sensorManager.getDefaultSensor（Sensor.TYPE_GYROSCOPE），\n      SensorManager.SENSOR_DELAY_NORMAL）\n  } \n  fun unregisterIfActive（）{ \n    如果（eventSink == null）返回\n     sensorManager.unregisterListener（这个）\n  } \n}//在Activity中使用上述类。\n类 MainActivity：FlutterActivity（）{ \n  var sensorListener：SensorListener？= NULL \n\n  倍率乐趣的onCreate（savedInstanceState：束）{ \n    超级 .onCreate（savedInstanceState）\n    GeneratedPluginRegistrant.registerWith（这个）\n    sensorListener = SensorListener（\n      getSystemService（Context.SENSOR_SERVICE）作为的SensorManager）\n    VAL信道=的EventChannel（flutterView， “foo”的）\n    信道。 setStreamHandler（sensorListener）\n  } \n\n  重写有趣的 onPause（）{ \n    sensorListener？.unregisterIfActive（）\n    super .onPause（）\n  }\n\n  重写fun onResume（）{ \n    sensorListener？.registerIfActive（）\n    super .onResume（）\n  } \n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br")])]),s("p",[e._v("如果您"),s("code",[e._v("android.arch.lifecycle")]),e._v("在应用中使用该软件包，则可以"),s("code",[e._v("SensorListener")]),e._v("将其设置为，从而使其更加自给"),s("code",[e._v("LifecycleObserver")]),e._v("。")]),e._v(" "),s("p",[s("strong",[e._v("精美的印刷品。")]),e._v(" *流处理程序的寿命。*平台端流处理程序有两种方法，"),s("code",[e._v("onListen")]),e._v("和"),s("code",[e._v("onCancel")]),e._v("，每当Dart流的侦听器数量分别从零变为一并返回时，就会调用。这可能会发生多次。流处理程序实现应该在调用前者时开始将事件倒入事件接收器，并在调用后者时停止。此外，当环境应用程序组件未运行时，它应该暂停。上面的代码提供了一个典型示例。在幕后，流处理程序当然只是二进制消息处理程序，使用事件通道的名称在Flutter视图中注册。")]),e._v(" "),s("p",[e._v("*编解码器。*事件通道配置有方法编解码器，从而使我们能够区分成功事件和错误事件，就像方法通道能够区分成功结果和错误结果一样。")]),e._v(" "),s("p",[e._v("*流处理程序参数和错误。*的"),s("code",[e._v("onListen")]),e._v("和"),s("code",[e._v("onCancel")]),e._v("流处理方法是通过方法通道调用调用。因此，我们有从Dart到平台的控制方法调用以及相反方向的事件消息，它们都在同一逻辑通道上。此设置允许将参数传递给两种控制方法，并报告任何错误。在Dart端，调用时会给出参数（如果有）"),s("code",[e._v("receiveBroadcastStream")]),e._v("。这意味着它们仅被指定一次，而与流生存期内的调用次数"),s("code",[e._v("onListen")]),e._v("和"),s("code",[e._v("onCancel")]),e._v("发生次数无关。报告回的所有错误都将被记录。")]),e._v(" "),s("p",[e._v("*流结束。*事件接收器具有"),s("code",[e._v("endOfStream")]),e._v("可以调用的方法，以发出信号，表示不会发送其他成功或错误事件。空二进制消息用于此目的。在Dart端接收后，流将关闭。")]),e._v(" "),s("p",[s("em",[e._v("溪流的生命")]),e._v("。Dart流由从传入的平台通道消息馈送的流控制器支持。使用事件通道的名称注册二进制消息处理程序，以仅在流具有侦听器时才接收传入消息。")]),e._v(" "),s("h1",{attrs:{id:"使用指南"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用指南"}},[e._v("#")]),e._v(" 使用指南")]),e._v(" "),s("h2",{attrs:{id:"通过域为频道前缀添加唯一性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过域为频道前缀添加唯一性"}},[e._v("#")]),e._v(" 通过域为频道前缀添加唯一性")]),e._v(" "),s("p",[e._v("频道名称只是字符串，但在用于您应用程序中不同目的的所有频道对象中，它们必须是唯一的。您可以使用任何合适的命名方案来实现。但是，"),s("em",[e._v("对于插件")]),e._v("中使用的"),s("em",[e._v("渠道")]),e._v("，推荐的方法是采用域名和插件名称前缀，例如at所开发的插件所使用"),s("code",[e._v("some.body.example.com/sensors/foo")]),e._v("的"),s("code",[e._v("foo")]),e._v("渠道。这样做可以使插件使用者在其应用程序中组合任意数量的插件，而不会出现频道名称冲突的风险。"),s("code",[e._v("sensors``some.body``example.com")])]),e._v(" "),s("h2",{attrs:{id:"考虑将平台通道视为模块内通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#考虑将平台通道视为模块内通信"}},[e._v("#")]),e._v(" 考虑将平台通道视为模块内通信")]),e._v(" "),s("p",[e._v("在分布式系统中调用远程过程调用的代码在表面上看起来类似于使用方法通道的代码：您调用由字符串给定的方法，并序列化参数和结果。由于分布式系统组件通常是独立开发和部署的，因此健壮的请求和回复检查至关重要，并且通常在网络两侧以检查和日志的方式进行。")]),e._v(" "),s("p",[e._v("另一方面，平台通道将在同一组件中一起开发和部署的三段代码粘合在一起。")]),e._v(" "),s("p",[e._v("Java /科特林↔Dart↔Objective-C / Swift")]),e._v(" "),s("p",[e._v("实际上，将这样的三合会打包到"),s("em",[e._v("单个代码模块")]),e._v("（例如Flutter插件）中通常很有意义。这意味着跨方法通道调用进行参数和结果检查的需求应与跨同一模块内的常规方法调用进行这种检查的需求可比。")]),e._v(" "),s("p",[e._v("在模块内部，我们主要关心的是防止编程错误，这些错误超出了编译器的静态检查范围，并且在运行时未被发现，直到它们在时间或空间上将其局部炸毁为止。合理的编码风格是使用类型或断言使假设明确，从而使我们能够快速干净地失败，例如出现异常。当然，具体内容因编程语言而异。例子：")]),e._v(" "),s("ul",[s("li",[e._v("如果期望通过平台通道接收的值具有某种类型，请立即将其分配给该类型的变量。")]),e._v(" "),s("li",[e._v("如果期望通过平台通道接收到的值是非空的，则可以将其设置为立即取消引用，或者断言在存储该值以供以后使用之前非空。根据您的编程语言，您也许可以将其分配给非空类型的变量。")])]),e._v(" "),s("p",[e._v("两个简单的例子：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// Dart：我们希望收到一个非null的整数列表。\n为（最终 INTÑ 在 AWAIT channel.invokeMethod（ 'getFib'，100））{ \n  打印（N * N）; \n}// Android：我们期望\n//字符串处理映射中提供//异步处理的非null名称和年龄参数。\nchannel.setMethodCallHandler {通话，结果-> \n  when（call.method）{ \n    “ bar”-> { \n      val名称：字符串= call.argument（“ name”）\n      val年龄：Int = call.argument（“ age”）\n      进程（名称，年龄，结果）\n    } \n    其他 -> result.notImplemented（）\n  } \n} \n：\n有趣的过程（名称：字符串，年龄：整数，结果：结果）{...}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br")])]),s("p",[e._v("Android代码利用了通用类型的"),s("code",[e._v("T argument(String key)")]),e._v("方法，"),s("code",[e._v("MethodCall")]),e._v("该方法在参数中查找键（假定为映射），并将找到的值强制转换为目标（调用站点）类型。如果由于某种原因失败，将引发一个适当的异常。从方法调用处理程序中抛出该异常后，它将被记录下来，并将错误结果发送到Dart端。")]),e._v(" "),s("h2",{attrs:{id:"不要嘲笑平台频道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不要嘲笑平台频道"}},[e._v("#")]),e._v(" 不要嘲笑平台频道")]),e._v(" "),s("p",[e._v("（打算用双关语。）为使用平台通道的Dart代码编写单元测试时，可能会像网络连接一样对通道对象进行模拟。")]),e._v(" "),s("p",[e._v("您当然可以这样做，但是实际上不需要嘲笑通道对象就可以在单元测试中很好地发挥作用。相反，您可以注册模拟消息或方法处理程序，以在特定测试期间扮演平台的角色。这是"),s("code",[e._v("hello")]),e._v("应该"),s("code",[e._v("bar")]),e._v("在channel上调用方法的函数的单元测试"),s("code",[e._v("foo")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("测试（ '会从平台问候'，（）异步 { \n  const的通道= MethodChannel（ '富'）; \n  channel.setMockMethodCallHandler（（MethodCall调用）异步 { \n    如果（call.method == '酒吧'）\n      返回 “你好，$ { call.arguments}'; \n    throw MissingPluginException （）; \n  }）; Expect \n  （等待 hello（'world'），'平台说：Hello，world'）; \n}）;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("要测试设置消息或方法处理程序的代码，可以使用来合成传入的消息"),s("code",[e._v("BinaryMessages.handlePlatformMessage")]),e._v("。目前，此方法尚未在平台通道上进行镜像，但可以轻松实现，如下面的代码所示。该代码定义了一个类的单元测试，该类"),s("code",[e._v("Hello")]),e._v("应该在返回问候语的同时收集"),s("code",[e._v("bar")]),e._v("channel 上方法调用的传入参数"),s("code",[e._v("foo")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("test（'收集传入参数'，（）异步 { \n  const channel = MethodChannel（'foo'）; \n  final hello = Hello（）; \n  final String result = await handleMockCall（\n    channel，\n    MethodCall（'bar'，'world'），\n  ） ;; \n  Expect（result，contains（'Hello，world'））; \n  Expect（hello.collectedArguments，contains（'world'））; \n}）;//可以成为类MethodChannel上的实例方法。\nFuture < dynamic > handleMockCall（\n  MethodChannel channel，\n  MethodCall call，\n）async { \n  动态结果；\n  等待 BinaryMessages。handlePlatformMessage（\n    channel.name，\n    channel.codec.encodeMethodCall（call），\n    （ByteData reply）{ \n      if（reply == null）\n        throw MissingPluginException（）; \n      result = channel.codec.decodeEnvelope（reply）; \n    }，\n  ）; \n  返回结果；\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br")])]),s("p",[e._v("上面的两个示例在单元测试中都声明了通道对象。除非您担心通道名称和编解码器重复，否则这可以正常工作，因为具有相同名称和编解码器的所有通道对象都是等效的。您可以通过将通道声明为"),s("code",[e._v("**const**")]),e._v("生产代码和测试可见的位置来避免重复。")]),e._v(" "),s("p",[e._v("您不需要的是提供一种将模拟通道注入生产代码的方法。")]),e._v(" "),s("h2",{attrs:{id:"考虑针对平台交互进行自动化测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#考虑针对平台交互进行自动化测试"}},[e._v("#")]),e._v(" 考虑针对平台交互进行自动化测试")]),e._v(" "),s("p",[e._v("平台通道非常简单，但是通过自定义的Dart API从Flutter UI使所有工作正常进行，并由单独的Java / Kotlin和Objective-C / Swift实现作为后备，确实需要多加注意。在实践中，要使设置在您的应用程序进行更改时保持正常运行，就需要进行自动测试以防止回归。仅凭单元测试无法做到这一点，因为您需要运行一个真正的应用程序来让平台通道与平台实际对话。")]),e._v(" "),s("p",[e._v("Flutter附带了"),s("code",[e._v("flutter_driver")]),e._v("集成测试框架，使您可以测试在真实设备和仿真器上运行的Flutter应用程序。但是"),s("code",[e._v("flutter_driver")]),e._v("目前尚未与其他框架集成，从而无法跨Flutter和平台组件进行测试。我有信心这是Flutter将来会改进的领域。")]),e._v(" "),s("p",[e._v("在某些情况下，您可以"),s("code",[e._v("flutter_driver")]),e._v("按原样使用以测试平台通道的使用情况。这要求您的Flutter用户界面可用于触发任何平台交互，然后对其进行足够详细的更新，以使您的测试能够确定交互的结果。")]),e._v(" "),s("p",[e._v("如果您不在这种情况下，或者将平台通道使用情况打包为需要模块测试的Flutter插件，则可以编写一个简单的Flutter应用进行测试。该应用应具有上述特征，然后可以使用来执行"),s("code",[e._v("flutter_driver")]),e._v("。您可以在"),s("a",{attrs:{href:"https://github.com/flutter/flutter/tree/master/dev/integration_tests/platform_interaction",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flutter GitHub存储库中"),s("OutboundLink")],1),e._v("找到一个示例。")]),e._v(" "),s("h2",{attrs:{id:"让平台端准备好接收同步呼叫"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#让平台端准备好接收同步呼叫"}},[e._v("#")]),e._v(" 让平台端准备好接收同步呼叫")]),e._v(" "),s("p",[e._v("平台通道仅是异步的。但是，有很多平台API可以同步调用您的主机应用程序组件，以寻求信息或帮助，或者提供机会之窗。一个例子是"),s("code",[e._v("Activity.onSaveInstanceState")]),e._v("在Android上。保持同步意味着必须在呼入电话返回之前完成所有操作。现在，您可能希望在此类处理中包含来自Dart端的信息，但是一旦同步调用已在主UI线程上激活，就开始发送异步消息为时已晚。")]),e._v(" "),s("p",[e._v("Flutter使用的方法（尤其是用于语义/可访问性信息的方法）是，只要信息在Dart端发生更改，就主动将更新（或更新）信息发送到平台端。然后，当同步调用到达时，来自Dart端的信息已经存在并且可用于平台端代码。")]),e._v(" "),s("h1",{attrs:{id:"资源资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资源资源"}},[e._v("#")]),e._v(" 资源资源")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://docs.flutter.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flutter API文档"),s("OutboundLink")],1),e._v("：")]),e._v(" "),s("ul",[s("li",[e._v("用于"),s("a",{attrs:{href:"https://docs.flutter.io/flutter/services/services-library.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("服务库的"),s("OutboundLink")],1),e._v(" DartDoc，其中包含Dart平台的通道类型。")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://docs.flutter.io/javadoc/io/flutter/plugin/common/package-summary.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("io.flutter.plugins.common程序包的"),s("OutboundLink")],1),e._v(" JavaDoc，其中包含Android平台通道类型。")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://docs.flutter.io/objcdoc/Classes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS Flutter库的"),s("OutboundLink")],1),e._v(" ObjcDoc 。")])]),e._v(" "),s("p",[e._v("指南：")]),e._v(" "),s("ul",[s("li",[e._v("该"),s("a",{attrs:{href:"https://flutter.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("flutter.io网站"),s("OutboundLink")],1),e._v("文件"),s("a",{attrs:{href:"https://flutter.io/platform-channels/",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何使用方法渠道"),s("OutboundLink")],1),e._v("和参与使用标准方法编解码器达特/安卓/ iOS的价值转换。")]),e._v(" "),s("li",[e._v("The "),s("em",[e._v("Boring Flutter Development Show")]),e._v("，第6集："),s("a",{attrs:{href:"https://youtu.be/ht2bDlJd2c4",target:"_blank",rel:"noopener noreferrer"}},[e._v("软件包和插件"),s("OutboundLink")],1),e._v("是一个YouTube视频，展示了正在使用平台渠道实时实施的Flutter插件。")])]),e._v(" "),s("p",[e._v("代码示例：")]),e._v(" "),s("ul",[s("li",[e._v("所述"),s("a",{attrs:{href:"https://github.com/flutter/flutter",target:"_blank",rel:"noopener noreferrer"}},[e._v("颤振/扑GitHub库"),s("OutboundLink")],1),e._v("包含"),s("a",{attrs:{href:"https://github.com/flutter/flutter/tree/master/examples/platform_channel",target:"_blank",rel:"noopener noreferrer"}},[e._v("一个基本示例"),s("OutboundLink")],1),e._v("的使用方法和事件信道到接入设备的电池信息，在一个完整的颤振应用包裹起来的。")]),e._v(" "),s("li",[e._v("该"),s("a",{attrs:{href:"https://github.com/flutter/plugins",target:"_blank",rel:"noopener noreferrer"}},[e._v("扑/插件GitHub库"),s("OutboundLink")],1),e._v("包含了使用平台的通道，实现扑插件的几个例子。该代码位于按插件组织的"),s("a",{attrs:{href:"https://github.com/flutter/plugins/tree/master/packages",target:"_blank",rel:"noopener noreferrer"}},[e._v("packages"),s("OutboundLink")],1),e._v("子文件夹中。每个插件都包含一个完整的示例应用程序。")])])])}),[],!1,null,null,null);n.default=t.exports}}]);