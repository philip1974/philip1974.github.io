(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{724:function(t,e,r){"use strict";r.r(e);var a=r(44),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("作者：易旭昕")]),t._v(" "),r("p",[t._v("原文链接："),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/232005984",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zhuanlan.zhihu.com/p/232005984"),r("OutboundLink")],1)])]),t._v(" "),r("p",[r("strong",[t._v("写作费时，敬请点赞，关注，收藏三连。")])]),t._v(" "),r("p",[t._v("Flutter 渲染引擎在 iOS 上的实现请参考我的文章 "),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/214099612",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flutter 渲染引擎详解 - iOS Metal 篇"),r("OutboundLink")],1),t._v("。")]),t._v(" "),r("p",[t._v("Flutter 渲染引擎在 Android 上也支持三种渲染方式，分别是纯软件（CPU），GL 和 Vulkan。其中纯软件模式是运行时由 Settings 的 enable_software_rendering 开关控制，默认为 false，目前只看到是通过命令行开关来控制，猜测是用于特定的测试用途。")]),t._v(" "),r("p",[t._v("跟 iOS 不一样的是，Flutter 在 Android 上并不是动态判断系统和硬件环境，在运行时来选择 Vulkan 或者 GL，而是需要开发者自行编译一个开启 SHELL_ENABLE_VULKAN 宏的 Flutter Engine，可能 Skia 对 Vulkan 在 Android 上的支持还不够完善的缘故，这个宏是默认关闭的，所以 Flutter 在 Android 上目前还是以 GL 为主。")]),t._v(" "),r("p",[t._v("这篇文章的主要内容是讲解在 Android 上，Flutter 渲染引擎：")]),t._v(" "),r("ol",[r("li",[t._v("需要的 GL GPU 上下文环境是如何完成初始化；")]),t._v(" "),r("li",[t._v("目标输出 Surface 的设置过程；")]),t._v(" "),r("li",[t._v("渲染流水线执行光栅化的调用过程。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-f83b906dbb8bda3c876a7bf18756c3f8_1440w.jpg",alt:"img"}})]),t._v(" "),r("p",[t._v("上图显示了 Flutter 渲染引擎在 Android 上主要涉及的对象，黄色背景是平台相关的适配对象，白色背景是平台无关的通用对象。后面的内容我们会频繁地引用图中的对象，这张图可以方便读者了解它们之间的关系。")]),t._v(" "),r("blockquote",[r("p",[t._v("Flutter 在 1.20 之前的版本，Context 和 Surface 这部分的实现存在比较多的 hardcode，代码逻辑比较混乱，1.20 版本做了比较大的重构，整体设计跟 iOS 基本趋同，本文是根据 1.20 的代码写就。")])]),t._v(" "),r("h2",{attrs:{id:"gl-gpu-上下文环境初始化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gl-gpu-上下文环境初始化"}},[t._v("#")]),t._v(" GL GPU 上下文环境初始化")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-0f4c5bfae9efe030cd38a81f106203f2_1440w.jpg",alt:"img"}})]),t._v(" "),r("p",[t._v("上图显示了 Android 应用在主线程初始化 Flutter Engine 的调用栈：")]),t._v(" "),r("ol",[r("li",[t._v("Flutter Engine Native 部分的主要入口在 AndroidShellHolder，它在 engine 初始化的时候被创建；")]),t._v(" "),r("li",[t._v("AndroidShellHolder 创建 Shell 并持有它；")]),t._v(" "),r("li",[t._v("Shell 在创建时调用 AndroidShellHolder 提供的 Callback 创建 PlatformViewAndroid 并获得所有权；")]),t._v(" "),r("li",[t._v("PlatformViewAndroid 在被创建时先创建 AndroidContextGL，然后把它传递给接着创建的 AndroidSurfaceGL，最后 PlatformViewAndroid 持有 AndroidSurfaceGL，AndroidSurfaceGL 持有 AndroidContextGL；")])]),t._v(" "),r("p",[t._v("AndroidContextGL 提供了 Flutter 渲染引擎所需要的 GL 上下文环境。它会先创建两个 EGLContext，一个 main context 在 raster 线程用于光栅化，一个 resource context 在 io 线程用于图片纹理上传，因为 main context 是 resource context 的 share context，所以 resource context 上传的纹理可以被 main context 直接使用。AndroidSurfaceGL 在构建时会马上请求 AndroidContextGL 创建 offscreen 的 AndroidEGLSurface。AndroidEGLSurface 是 EGLSurface 的封装，对于 offscreen 来说，只是用一个 1x1 的 PbufferSurface 作为 resource context 的 target EGLSurface，这个PbufferSurface 只是作为必须的占位符，没有实际用途。")]),t._v(" "),r("p",[t._v("AndroidSurfaceGL 构建完毕之后，Flutter 渲染引擎所需要的 GL 上下文环境就已经初始化完成了。跟 iOS Metal 不同的是，因为 GL Context 的线程相关性，Skia GrContext 需要延迟到 GL Context 设置到目标线程真正使用的时候才创建，无法提前创建。")]),t._v(" "),r("h2",{attrs:{id:"设置目标输出-surface"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设置目标输出-surface"}},[t._v("#")]),t._v(" 设置目标输出 Surface")]),t._v(" "),r("p",[t._v("Flutter 允许应用选择 "),r("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//developer.android.com/reference/android/view/SurfaceView",target:"_blank",rel:"noopener noreferrer"}},[t._v("SurfaceView"),r("OutboundLink")],1),t._v(" 或者 "),r("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//developer.android.com/reference/android/view/TextureView",target:"_blank",rel:"noopener noreferrer"}},[t._v("TextureView"),r("OutboundLink")],1),t._v(" 作为目标输出 Window，无论是选择 SurfaceView 还是 TextureView，Flutter 都是通过注册回调方法，在 SurfaceView/TextureView 可见时获得回调，得到封装了 Android Native Window 的 "),r("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//developer.android.com/reference/android/view/Surface",target:"_blank",rel:"noopener noreferrer"}},[t._v("Surface"),r("OutboundLink")],1),t._v(" 对象。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-fee64276d3b814b9df650cca641d5749_1440w.jpg",alt:"img"}})]),t._v(" "),r("ol",[r("li",[t._v("当主线程获得系统回调通知 "),r("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//developer.android.com/reference/android/view/Surface",target:"_blank",rel:"noopener noreferrer"}},[t._v("Surface"),r("OutboundLink")],1),t._v(" 已经创建时，它会调用 Engine Native 的代码 SurfaceCreated（platform_view_android_jni_impl.cc）；")]),t._v(" "),r("li",[t._v("SurfaceCreated 会取出 Surface 对象里面的 Window Handle，并封装成 AndroidNativeWindow 对象传递给 PlatformViewAndroid::NotifyCreated；")]),t._v(" "),r("li",[t._v("PlatformViewAndroid::NotifyCreated 在主线程被调用时，会通知 raster 线程，并同步等待结果；")]),t._v(" "),r("li",[t._v("raster 线程接收到消息后会调用 AndroidSurfaceGL::SetNativeWindow；")]),t._v(" "),r("li",[t._v("AndroidSurfaceGL::SetNativeWindow 调用 AndroidContextGL::CreateOnscreenSurface；")])]),t._v(" "),r("div",{staticClass:"language-cpp line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-cpp"}},[r("code",[t._v("std"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("unique_ptr"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("AndroidEGLSurface"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" AndroidContextGL"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("CreateOnscreenSurface")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    fml"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("RefPtr"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("AndroidNativeWindow"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" window"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  EGLDisplay display "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" environment_"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("Display")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" EGLint attribs"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("EGL_NONE"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  EGLSurface surface "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("eglCreateWindowSurface")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      display"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" config_"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("reinterpret_cast")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("EGLNativeWindowType"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("window"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("handle")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      attribs"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" std"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("make_unique"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("AndroidEGLSurface"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("surface"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" display"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" context_"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br")])]),r("p",[t._v("AndroidContextGL::CreateOnscreenSurface 实际上就是使用 Window Handle 创建对应的 EGLSurface，并包装成 AndroidEGLSurface 返回给 AndroidSurfaceGL 作为光栅化输出的 onscreen EGLSurface。")]),t._v(" "),r("p",[t._v("主线程等待完 raster 线程创建 onscreen EGLSurface 后，再次同步请求 raster 线程调用 PlatformViewAndroid::CreateRenderingSurface，实际上这里就是创建 GPUSurfaceGL。GPUSurfaceGL 被创建时会先请求 AndroidSurfaceGL 将 AndroidContextGL 里面的 main EGLContext 作为 raster 线程的当前 GL 上下文，然后创建对应的 GrContext 并持有。这个 GrContext 将来就会用于光栅化。")]),t._v(" "),r("p",[t._v("主线程同步等待 GPUSurfaceGL 创建完毕后，把获得的 GPUSurfaceGL 对象通过 Shell 传递给 Rasterizer 持有，到这里光栅化器就完成了目标输出 Surface 的设置，现在我们可以开始绘制第一帧了。")]),t._v(" "),r("h2",{attrs:{id:"光栅化输出"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#光栅化输出"}},[t._v("#")]),t._v(" 光栅化输出")]),t._v(" "),r("p",[t._v("关于 Flutter 渲染流水线比较完整的说明请参考我之前的文章 "),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/38431912",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flutter 渲染流水线浅析"),r("OutboundLink")],1),t._v("，在这里我们只关注光栅化的部分。Flutter 光栅化的过程比较简单，Android 和 iOS 基本流程也是大同小异：")]),t._v(" "),r("ol",[r("li",[t._v("Rasterizer 请求 GPUSurfaceGL 创建一个 SkSurface，这个 SkSurface 实际上就是当前 EGLContext 的 FBO 0 的包装，也就是之前创建的 onscreen EGLSurface，实际上就是源自 SurfaceView 或者 TextureView 的 Android Native Window；")]),t._v(" "),r("li",[t._v("通过上述获得 SkSurface 对象，取得对应的 SkCanvas 对象；")]),t._v(" "),r("li",[t._v("将生成的图层树里面的 DisplayList（SkPicture）通过上面的 SkCanvas 逐个绘制到 SkSurface 上，Skia 会先存储经过预处理的 2D 绘图指令；")]),t._v(" "),r("li",[t._v("Flush SkCanvas，相当于生成相应的 GL GPU 绘图指令请求 GPU 执行；")]),t._v(" "),r("li",[t._v("最后调用 eglSwapBuffers 请求 Android Native Window 交换前后台缓冲区，并触发 Android UI 的重绘（TextureView）或者 SurfaceFlinger 的窗口重新合成（SurfaceView）；")])])])}),[],!1,null,null,null);e.default=n.exports}}]);